# 一、链表的基本概念

### 知识回顾
顺序表的特点：以物理位置相邻表示逻辑关系。

顺序表的优点：任一元素均课随机存取。

顺序表的缺点：进行插入和删除操作时，需要移动大量的元素。储存空间不灵活。

### 链式存储结构
* 链式存储结构
    * 结点在储存器中的位置是任意的，即逻辑相邻的数据元素在物理上不一定相邻。
* 线性表的链式表示又称为【非顺序映像】或【链式映像】。
* 用一组物理位置任意的储存单元来存放线性表的数据元素。
* 这组储存单元既可以是连续的，也可以是不连续的，甚至是零散分布在内存中任意位置上的。
* 链表中元素的【逻辑次序和物理次序不一定相同】。

------------------------

* 与链式储存有关的术语
    1. 结点：数据元素的储存映射。由数据域和指针域两部分组成。

        <kbd>数据域</kbd><kbd>指针域</kbd>
    2. 链表：n个结点由指针链组成的一个链表。
        它是线性表的链式存储映像，称为线性表的链式存储结构。

    3. 单链表、双链表、循环链表：
        * 结点只有一个指针域的链表，称为单链表或线性链表。
        * 结点有两个指针域的链表，称为双链表。
        * 首尾相接的链表称为循环链表。
    4. 头指针、头结点和首元结点：
        * 头指针：是指向链表中第一个结点的指针。
        * 首元结点：是指链表中存储第一个数据元素a1的结点。
        * 头结点：是在链表的首元结点之前附设的一个结点。

        ----------------

        * 不带头结点：头指针存放第一个元素的地址。
        * 带头结点：头指针指向头结点，头结点指针域指向首元结点。

        * ### 讨论1：如何表示空表？
            > 无头结点时，头指针为空时表示空表。

            > 有头结点时，当头结点的指针域为空时表示空表。
        * ### 讨论2：在链表中设置头结点有什么好处？
            > 1、便于首元结点的处理。首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上操作和其它位置一致，无须进行特殊处理；

            > 2、便于空表和非空表的统一处理。无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。

        * ### 讨论3：头结点的数据域内装的是什么？
            > 头结点的数据域可以为空，也可以存放线性表长度等附加信息，但此结点不能计入链表长度值。
            
* ## 【链表（链式储存结构）的特点】
    1. 结点在储存器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻。
    2. 访问时只能通过头指针进入链表，并通过每个结点的指针域依次向后顺序扫描其余结点，所以寻找第一个结点和最后一个结点所花费的时间不等。这种存取元素的方法被称为【顺序存取法】。

    ---------------
    顺序表 -> 随机存取
    
    链表   -> 顺序存取

# 二、单链表的定义和表示
* 单链表的储存结构
```c
typedef int ElemType;
typedef struct node node, *listLink;
struct node
{
    ElemType data;
    listLink next;
};
```

# 三、单链表基本操作的实现
* 单链表的初始化（带头结点的单链表）
```c
Status initList(listLink *L)
{
    *L = (listLink)malloc(sizeof(node));
    if(*L == NULL)
    {
        exit(OVERFLOW);
    }
    (*L)->next = NULL;
    return OK;
}
```
* 判断链表是否为空（带头结点的单链表）
```c
int listEmpty(listLink L)
{
    return L->next == NULL;
}
```
* 单链表的销毁（链表销毁后不存在，从头指针开始依次释放）
```c
Status destroyList(listLink L)
{
    listLink p = L;
    listLink q = NULL;
    while(p != NULL)
    {
        q = p->next;
        free(p);
        p = q;
    }
    return OK;
}
```
* 清空链表（链表中无元素，头指针和头结点仍然存在）
```c
Status clearList(listLink L)
{
    listLink p = L->next;
    listLink q = NULL;
    while(p != NULL)
    {
        q = p->next;
        free(p);
        p = q;
    }
    return OK;
}
```
* 求链表表长（从首元结点开始，依次计数所有结点）
```c
int listCount(listLink L)
{
    int count = 0;
    listLink p = L->next;
    while(p != NULL)
    {
        count += 1;
        p = p->next;
    }
    return count;
}
```
* 部分总结
>重要操作
```c
p = L; //指向头结点
s = L->next; //s指向首元结点
p = p->next; //p指向下一结点
```
--------------------
> 重要操作
* 取链表中第i个元素的内容
```c
```